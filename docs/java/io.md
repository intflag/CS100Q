# Java IO
## 1、NIO BIO AIO
?> **面试题：** 常见的 IO 模型有哪些，各自的原理和优缺点是什么？
<!-- tabs:start -->

#### **参考回答**

### 1）BIO
- BIO (Blocking I/O)：同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成；
- 采用 BIO 通信模型的服务端，通常会有一个独立的线程监听客户端的连接，而且为了服务端能同时处理多个客户端请求，就必须采用多线程，主要原因是主要原因是 `socket.accept()`、`socket.read()`、`socket.write()` 涉及的三个主要函数都是同步阻塞的；
- 所以服务端在接收到客户端的连接请求后，会为每个客户端都创建一个新的线程进行链路处理，处理完成后通过输出流返回结果给客户端，然后销毁线程；
- 但是，我们知道在 Java 虚拟机中，线程是宝贵的资源，创建和销毁线程都需要额外的开销，而且，如果某个客户端的连接不做任何事的话，也会造成资源浪费，所以为了对 BIO 这种通信模型做优化，引入了线程池；
- 当服务端监听到有新的客户端接入时，将客户端的 Socket 封装成一个 Task，然后发送到线程池中进行处理，线程池会维护几个核心线程和一个线程队列，通过设置最大线程数和队列大小保证资源是可控的，这样无论多少个客户端并发访问，都不会有资源耗尽的问题，这种优化后的模型被称为伪异步 I/O 通信模型；
- 虽然伪异步 I/O 通信模型采用了线程池实现，因为它的底层仍然是同步阻塞的 BIO 模型，因此无法从根本上解决问题，在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型就无能为力了。

### 2）NIO


### 参考资料
- [BIO,NIO,AIO 总结【JavaGuide】](https://snailclimb.gitee.io/javaguide/#/docs/java/BIO-NIO-AIO?id=bionioaio-%e6%80%bb%e7%bb%93)
- [Netty入门教程——认识Netty【追那个小女孩】](https://www.jianshu.com/p/b9f3f6a16911)

#### **源码详解**



<!-- tabs:end -->
