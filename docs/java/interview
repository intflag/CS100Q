Java基础
数据类型
byte 1
short 2
char 2
int 4
float 4
long 8
double 8

抽象类和接口
抽象类可以有构造器，接口不可以
抽象类可以实例化，接口不可以
抽象类可以有属性，接口只能是不可变常量
抽象类可以声明抽象方法，也可以实现方法，接口只能声明方法
抽象类是单继承，多实现，接口是多继承
java8对接口新增了default方法和接口静态方法

final、finaly、finalize
final修饰的类不可以被继承，修饰的方法不可以被重写，修饰的变量为常量
finaly是java做异常处理的手段，除了调用system.exit(0) 可以保证代码被执行，通常用来做资源的释放和锁的释放等操作
finalize 方法名，该方法可以在垃圾回收之前做某些操作，但一般不推荐，因为垃圾回收的时机是由java虚拟机决定的

String StringBuffer StringBuilder
String用了final进行修饰，所以是不可变类，不可以被继承，并且是线程安全的
StringBuffer 也是线程安全的，内部用 synchronized 进行同步
StringBuilder 是线程不安全的，通常在大量字符串拼接的时候使用

反射
发射是在程序运行状态中，对任意一个类都能获取它的属性和方法，同时能调用它的属性和方法
实现反射的三种方式
类.class
对象.getClass()
Class.forName(全类名)

Java容器
ArrayList Vector LinkedList
ArrayList 底层是用数组实现的，支持随机访问，默认大小是 10，如果在调用 add 方法时容量不够，会进行扩容，扩容后的容量是之前的 1.5 倍，
同时会使用 Arrays.copy 方法做数据拷贝，这个代价是比较高的，所以最好在创建它的时候根据业务的实际情况指定一个大概的容量，避免频繁扩容
它是线程不安全的，如果想使用线程安全的集合可以通过集合工具类 Collections.synchronizedList 得到一个线程安全的 ArrayList，另一种方法是使用并发包下的 CopyOnWriteArrayList
读写分离的，读操作是在原数组上进行，写操作是在一个复制的数组上进行的，所以适合读多写少的场景

Vector是 java 早期提供的集合实现，底层是也数组实现的，默认容量是 10，每次扩容为之前的 2 倍，它是线程安全的，因为他的添加、删除、查找等方法都用了 synchronized 进行同步

LinkedList 底层是通过双向链表实现的，内部有一个静态内部类 Node，里面有前驱指针和后继指针，并且还保存了头指针和尾指针，在查找的时候，如果索引靠右，就从头指针向后搜索，否则从尾指针向前搜索
不支持随机访问，但插入和删除操作比较快，只要改变指针的指向就可以了

HashMap HashTable
HashMap 哈希表的实现，底层是数组加链表实现的
默认大小是 16，在添加元素的时候，当元素个数大于一个临界值的时候会进行扩容，临界值 = 容量 * 装载因子，默认是 0.75，扩容后的容量是之前的 2 倍
HashMap可以存储 null 键值对，null键会被存储到数组下标为 0 的位置上
HashMap是通过拉链发解决哈希冲突的，JDK 8 开始，当链表长度大于 8 时，会转成红黑树，小于等于 6 时重新转为链表，选择 8 是遵循泊松分布，还有链表查找的时间复杂度时 O(n) 而红黑树是 O(logn)
HashMap是线程不安全的

HashTable 是线程安全的，它是 Java 早期哈希表的实现，默认容量为 11，每次扩容是 2n + 1，不支持存储 null 键值对
保证线程安全的原因是它的方法使用了 Synchronized 进行同步，当一个线程使用 put 方法时，其他线程不但不能使用 put 方法，连 get 方法也不能使用，也就是说会竞争同一把锁，所以效率比较低

通常并发环境下会使用 ConcurrentHashMap，它与 HashMap 的实现类似，但与 HashTable竞争同一把锁不同的是，它采用了分段锁 Segment，每个 Segment 维护几个桶，多个线程可以同时访问不同分段锁上的桶
在插入或者查找的时候，先通过哈希算法定位到 Segment，然后使用变种算法进行一次再哈希，大大减少了哈希冲突发生的概率
在执行 size 方法时，会遍历 Segment 的数量然后累加起来，如果连续两次不加锁数量是一致的，那就认为结果是正确的，否则会对每个segment加锁
JDK 8 使用了并发度更高的 CAS 操作


LinkedHashMap
继承自 HashMap，同样具有快速查找的特性，在内部维护了一个双向链表，用来实现插入顺序或者 LRU 顺序
内部有一个变量 accessOrder，默认为 false，维护的是插入顺序，当 accessOrder 为 true 的时候维护 LRU 顺序
每次访问一个节点时，会将这个节点移动到链表尾部，保证链表尾部是最近访问的节点，首部是最近最久未访问的节点