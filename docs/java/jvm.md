# Java 虚拟机
## 1、运行时数据区
<!-- tabs:start -->

#### **参考回答**
?> **面试题：** 谈谈你对 JVM 内存模型的了解，以及每个区域的用途是什么？

- java虚拟机运行时数据区主要分线程隔离的和线程共享的；
-  <mark>&nbsp;线程隔离&nbsp;</mark>的有：<mark>&nbsp;程序计数器&nbsp;</mark> 、<mark>&nbsp;Java 虚拟机栈&nbsp;</mark> 、<mark>&nbsp;本地方法栈&nbsp;</mark> ；
    - 程序计数器主要同来记录正在执行的虚拟机字节码指令的地址，如果是正在执行的是本地方法则为空；
    - 然后每个方法执行的时候都要先创建一个`栈帧`，它里面主要保存着`局部变量表`、`操作数栈`、`常量池引用`等信息，方法从开始调用到执行结束对应着栈帧在 Java 虚拟机中`入栈`和`出栈`的过程；
    - 本地方法栈与虚拟机栈类似，只不过本地方法栈是为本地方法服务的，本地方法一般是 C、C++、汇编实现的，而且虚拟机没有对本地方法的语言、使用方式、数据结构做强制规定，可以由虚拟机自由实现，HotSpot 虚拟机就把二者合二为一了。
-  <mark>&nbsp;线程共享&nbsp;</mark>的有：<mark>&nbsp;堆&nbsp;</mark>和<mark>&nbsp;方法区&nbsp;</mark>，方法区中又包含<mark>&nbsp;运行时常量池&nbsp;</mark>；
    - `Java 堆`被所有`线程共享`，`几乎`所有的`对象实例`都在`堆分配内存`，之所以说几乎，是因为随着 JIT 编译器的发展，在编译时期经过`逃逸分析`，如果发现有些对象没有逃逸出方法，那么就有可能被`优化`成在虚拟机`栈上分配内存`，但这个不是绝对的；
    - Java 堆是`垃圾收集器`管理的主要区域，也被称为 `GC 堆`，现代的垃圾收集器基本都是采用`分代收集算法`，所有堆被分为`新生代 Young Generation`和`老年代 Old Generation`；
    - 堆不需要连续内存，可以动态增加内存，增加失败抛出 OutOfMemoryError 错误；

#### **源码详解**



<!-- tabs:end -->

## 2、垃圾回收
?> **面试题：** JVM 是怎么进行对象回收判断的，具体的垃圾回收算法是什么？

<!-- tabs:start -->

#### **参考回答**

### 1）对象回收判断
- 有<mark>&nbsp;引用计数器算法&nbsp;</mark>，原理主要是给对象添加一个引用计数器，每当对象增加一个引用计数器就加 1，引用失效计数器就减 1，引用计数器为 0 的对象可以被回收，但是，当两个对象出现循环引用的时候，计数器永远不为 0，导致对象无法被回收，所以虚拟机现在都不采用这种算法；
- 还有一种是<mark>&nbsp;可达性分析算法&nbsp;</mark>，原理是以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的就是能被回收的，现在的虚拟机大多采用的是这种算法。

### 2）垃圾回收算法
- <mark>&nbsp;标记-清除&nbsp;</mark>算法：标记阶段会根据对象的存活状态在对象头部打上标记，清除阶段回收对象取消标志位，另外，还会将当前回收的区块和前一个连续的空闲区块合并，但是在分配的时候会将大区块分隔成多个小区块，这样就会产生不连续的内存碎片，导致无法给大对象分配内存；
- <mark>&nbsp;标记-整理&nbsp;</mark>算法：让所有存活的对象都往一端移动，然后直接清理边界以外的内存，虽然这样不会产生内存碎片，但是需要移动大量对象，处理效率比较低；
- <mark>&nbsp;复制&nbsp;</mark>算法：原理是将内存划分成大小相等的两块，每次只是用其中一块，当这一块内存用完就将还存活的对象复制到另一块上，然后清理之前那一块，但这种效率只有 50%；
- 现在的商业虚拟机都是采用这种算法回收新生代，但不是分成相等的两块，而是一块较大的 <mark>&nbsp;Eden&nbsp;</mark> 空间和两块较小的 <mark>&nbsp;Survivor&nbsp;</mark> 空间，每次使用一块 Eden 和一块 Survivor ，回收的时候，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor；
- HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 <mark>&nbsp;8:1&nbsp;</mark>，保证了内存的利用率达到 90%。如果每次回收时有超过 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。
- <mark>&nbsp;分代收集&nbsp;</mark>：现在的商业虚拟机基本都采用分代收集，一般将堆划分成<mark>&nbsp;新生代&nbsp;</mark>和<mark>&nbsp;老年代&nbsp;</mark>，新生代通常使用`复制算法`，老年代使用`标记-清除`或者`标记-整理`算法；

#### **源码详解**



<!-- tabs:end -->

## 3、垃圾收集器
?> **面试题：** JVM 有哪些垃圾收集器，各自的优缺点及使用场景是什么？

<!-- tabs:start -->

#### **参考回答**
常见的垃圾收集器有 7 种，新生代收集器有：Serial、ParNew、Parallel Scavenge，老年代收集器有：Serial Old、Parallel Old、CMS，堆内存垃圾收集器有：G1；

### 1）新生代收集器
- <mark>&nbsp;Serial&nbsp;</mark> 回收的范围是新生代，采用单线程和复制算法进行垃圾收集，它在收集时所有的用户线程都要等待，适合在 Client 场景下使用，能与其搭配的老年代收集器是 CMS 与 Serial Old；
- <mark>&nbsp;ParNew&nbsp;</mark> 收集的范围也是新生代，但它使用多线程和复制算法进行垃圾收集，相当于 Serial 收集器的多线程版本，适合在 Server 场景下使用，能与其搭配的老年代收集器是 CMS 与 Serial Old；
- <mark>&nbsp;Parallel Scavenge&nbsp;</mark> 同样用来回收新生代，采用多线程和复制算法进行垃圾收集，但是它和 ParNew 不同的是，它会尽可能的缩短垃圾收集时用户线程的停顿时间，来达到一个可控制的吞吐量，比如程序一共运行了 100 分钟，垃圾回收占用 1 分钟，那吞吐量就等于 99%；
- 它还可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），默认是开启的，这样就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量；
- 适合比较注重吞吐量，能高效利用 CPU 进行计算，且不需要太多交互场景，因为如果频繁交互，就需要缩短停顿时间，垃圾回收更频繁，吞吐量降低；

### 2）老年代收集器
- <mark>&nbsp;Serial Old &nbsp;</mark> 收集器是 Serial 的老年代版本，采用单线程和标记-整理算法进行垃圾收集，适合在 Client 场景下使用，与 Parallel Scavenge 收集器搭配，作为 CMS 收集器的后备预案；
- <mark>&nbsp;Paraller Old&nbsp;</mark> 是 Parallel Scavenge 的老年代版本，采用多线程和标记-整理算法进行垃圾收集；
- <mark>&nbsp;CMS (Concurrent Mark Sweep)&nbsp;</mark> 从名字上就可以知道它采用的是标记-清除算法，垃圾回收主要包含 4 个步骤：
    - 初始标记：标记一下 GC Roots 能直接关联到的对象，速度较快，需要停顿；
    - 并发标记：进行 GC Roots Tracing，标记出全部的垃圾对象，耗时较长，不需要停顿；
    - 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
    - 并发清除：用标记-清除算法清除垃圾对象，耗时较长，不需要停顿。
- CMS 收集器也有一些缺点：
    - 并发阶段会和工作现场争抢 CPU 资源；
    - 采用标记-清除算法会产生空间碎片，虚拟机提供一个参数，用于当 CMS 顶不住需要进行 FullGC 时整理空间碎片，但是整理的过程是用户线程是得停止工作的，所以停顿的时间会变长；
    - 浮动垃圾问题，因为在并发清理的时候允许用户线程继续执行，而执行就可能产生新的垃圾进入老年代，所以需要预留一部分空间给这些浮动垃圾，而当这些浮动垃圾过多在 CMS 运行期间爆了，那 CMS 就会出现 Concurrent Mode Failure ，这是时候就得后备的 Serial Old 上来重新进行老年代的垃圾收集，所以停顿的时间就更长了。
    
### 3）G1 收集器
- <mark>&nbsp;G1 (Garbage-First)&nbsp;</mark> 是 HotSpot JDK1.7 时出现的可商用垃圾收集器，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能，HotSpot 团队研发它的目的是为了在以后能替换掉 JDK 1.5中发布的CMS收集器；
- 堆被分为新生代和老年代，其它收集器进行收集的范围要么是新生代，要么是老年代，而 G1 可以直接对新生代和老年代一起回收，能这样做的原因是 G1 把堆划分成多个大小相等的独立区域 Region ，新生代和老年代不再物理隔离；
- 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收；
- 这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能，通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region；
- 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描；
- 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：
    - 初始标记（Initial Marking）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的 Region 中创建对象，此阶段需要停顿线程，但耗时很短；
    - 并发标记（Concurrent Marking）：从 GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行；
    - 最终标记（Final Marking）：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行。
    - 筛选回收（Live Data Counting and Evacuation）：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

#### **源码详解**

![](http://images.intflag.com/jvm08.png)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行与并发：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并发指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

|收集器|范围|运行模式|算法|目标|适用场景|
|:----:|:----:|:----:|:----:|:----:|:----:|
|Serial|新生代|单线程串行|复制算法|响应速度优先|单CPU环境下的Client模式|
|ParNew|新生代|多线程串行|复制算法|响应速度优先|多CPU环境时在Server模式下与CMS配合|
|Parallel Scavenge|新生代|多线程串行|复制算法|吞吐量优先|在后台运算而不需要太多交互的任务|
|Serial Old|老年代|多线程串行|标记-整理|响应速度优先|单CPU环境下的Client模式、CMS的后备预案|
|Parallel Old|老年代|多线程串行|标记-整理|吞吐量优先|在后台运算而不需要太多交互的任务|
|CMS|老年代|并发|标记-清除|响应速度优先|集中在互联网站或B/S系统服务端上的Java应用|
|G1|both|并发|标记-整理+复制算法|响应速度优先|面向服务端应用，将来替换CMS|

### 1）Serial 收集器

![](http://images.intflag.com/jvm09.png)

Serial 翻译为串行，也就是说它以串行的方式执行。

它是单线程的收集器，只会使用一个线程进行垃圾收集工作。

它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。

### 2）PerNew 收集器

![](http://images.intflag.com/jvm10.png)

它是 Serial 收集器的多线程版本。

它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

### 3）Parallel Scavenge 收集器

与 ParNew 一样是多线程收集器。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

### 4）Serial Old 收集器

![](http://images.intflag.com/jvm11.png)

是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

### 5）Parallel Old 收集器

![](http://images.intflag.com/jvm12.png)

是 Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### 6）CMS 收集器

![](http://images.intflag.com/jvm13.png)

CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。

分为以下四个流程：

- 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
- 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- 并发清除：不需要停顿。
在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

具有以下缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

### 7）G1 收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。

![](http://images.intflag.com/jvm14.png)

G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。

![](http://images.intflag.com/jvm15.png)

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![](http://images.intflag.com/jvm16.png)

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

具备如下特点：

- 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

### 参考
- [cyc2018 垃圾收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8)

<!-- tabs:end -->


## 4、内存分配和回收策略

## 5、类加载机制



垃圾回收算法，
垃圾收集器，
jvm内存模型，每个区域用途，

各种oom的种类，
jvm调优经验，没有你也要做过，自己去设置启动参数，知道常见参数的含义，

类加载过程，
双亲委派，
什么时候young gc，full gc，各种情况进入老年代的方式，你知道的越多越好，因为吹起来就越自信，举个例子，逃逸分析是什么？markword里面有什么？