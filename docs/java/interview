Java基础
数据类型
byte 1
short 2
char 2
int 4
float 4
long 8
double 8

抽象类和接口
抽象类可以有构造器，接口不可以
抽象类可以实例化，接口不可以
抽象类可以有属性，接口只能是不可变常量
抽象类可以声明抽象方法，也可以实现方法，接口只能声明方法
抽象类是单继承，多实现，接口是多继承
java8对接口新增了default方法和接口静态方法

final、finaly、finalize
final修饰的类不可以被继承，修饰的方法不可以被重写，修饰的变量为常量
finaly是java做异常处理的手段，除了调用system.exit(0) 可以保证代码被执行，通常用来做资源的释放和锁的释放等操作
finalize 方法名，该方法可以在垃圾回收之前做某些操作，但一般不推荐，因为垃圾回收的时机是由java虚拟机决定的

String StringBuffer StringBuilder
String用了final进行修饰，所以是不可变类，不可以被继承，并且是线程安全的
StringBuffer 也是线程安全的，内部用 synchronized 进行同步
StringBuilder 是线程不安全的，通常在大量字符串拼接的时候使用

反射
发射是在程序运行状态中，对任意一个类都能获取它的属性和方法，同时能调用它的属性和方法
实现反射的三种方式
类.class
对象.getClass()
Class.forName(全类名)

Java容器
ArrayList Vector LinkedList
ArrayList 底层是用数组实现的，支持随机访问，默认大小是 10，如果在调用 add 方法时容量不够，会进行扩容，扩容后的容量是之前的 1.5 倍，
同时会使用 Arrays.copy 方法做数据拷贝，这个代价是比较高的，所以最好在创建它的时候根据业务的实际情况指定一个大概的容量，避免频繁扩容
它是线程不安全的，如果想使用线程安全的集合可以通过集合工具类 Collections.synchronizedList 得到一个线程安全的 ArrayList，另一种方法是使用并发包下的 CopyOnWriteArrayList
读写分离的，读操作是在原数组上进行，写操作是在一个复制的数组上进行的，所以适合读多写少的场景

Vector是 java 早期提供的集合实现，底层是也数组实现的，默认容量是 10，每次扩容为之前的 2 倍，它是线程安全的，因为他的添加、删除、查找等方法都用了 synchronized 进行同步

LinkedList 底层是通过双向链表实现的，内部有一个静态内部类 Node，里面有前驱指针和后继指针，并且还保存了头指针和尾指针，在查找的时候，如果索引靠右，就从头指针向后搜索，否则从尾指针向前搜索
不支持随机访问，但插入和删除操作比较快，只要改变指针的指向就可以了

HashMap HashTable
HashMap 哈希表的实现，底层是数组加链表实现的
默认大小是 16，在添加元素的时候，当元素个数大于一个临界值的时候会进行扩容，临界值 = 容量 * 装载因子，默认是 0.75，扩容后的容量是之前的 2 倍
HashMap可以存储 null 键值对，null键会被存储到数组下标为 0 的位置上
HashMap是通过拉链发解决哈希冲突的，JDK 8 开始，当链表长度大于 8 时，会转成红黑树，小于等于 6 时重新转为链表，选择 8 是遵循泊松分布，还有链表查找的时间复杂度时 O(n) 而红黑树是 O(logn)
HashMap是线程不安全的

HashTable 是线程安全的，它是 Java 早期哈希表的实现，默认容量为 11，每次扩容是 2n + 1，不支持存储 null 键值对
保证线程安全的原因是它的方法使用了 Synchronized 进行同步，当一个线程使用 put 方法时，其他线程不但不能使用 put 方法，连 get 方法也不能使用，也就是说会竞争同一把锁，所以效率比较低

通常并发环境下会使用 ConcurrentHashMap，它与 HashMap 的实现类似，但与 HashTable竞争同一把锁不同的是，它采用了分段锁 Segment，每个 Segment 维护几个桶，多个线程可以同时访问不同分段锁上的桶
在插入或者查找的时候，先通过哈希算法定位到 Segment，然后使用变种算法进行一次再哈希，大大减少了哈希冲突发生的概率
在执行 size 方法时，会遍历 Segment 的数量然后累加起来，如果连续两次不加锁数量是一致的，那就认为结果是正确的，否则会对每个segment加锁
JDK 8 使用了并发度更高的 CAS 操作


LinkedHashMap
继承自 HashMap，同样具有快速查找的特性，在内部维护了一个双向链表，用来实现插入顺序或者 LRU 顺序
内部有一个变量 accessOrder，默认为 false，维护的是插入顺序，当 accessOrder 为 true 的时候维护 LRU 顺序
每次访问一个节点时，会将这个节点移动到链表尾部，保证链表尾部是最近访问的节点，首部是最近最久未访问的节点

Java并发

进程和线程
进程是资源分配的最小单位，线程是 CPU 调度的最小单位
比如我们在使用微信时，会发现任务管理中至少会有三个进程，微信主进程，微信小程序进程，微信浏览器进程，而微信主进程中，发送文字是一个线程，发送语音可能是另一个线程
所以进程可以管理多个线程，而多个线程会共享进程的资源
在调度方面，线程上下文切换要比进程切换快很多

线程的生命周期
新建 - 就绪 - 运行 - 阻塞 - 死亡

实现多线程的方式
1 继承 Thread 类，重写 run 方法
2 实现 Runnable 接口，实现 run 方法
3 实现 Callable 接口，实现 call 方法，使用时需要用 FutureTask 包装一下，可以调用 get 方法异步获取线程返回值

线程池的定义、原理、实际应用
线程池是一种基于池化思想管理线程的工具
因为线程会占用资源，创建和销毁线程又会带来额外的开销，所以我们可以提前把线程创建出来，交给线程池统一管理，任务来的时候直接从线程池取出一个线程去执行任务，使用完毕后再归还到线程池中，以此来实现线程的复用

线程池实现原理
线程池是基于生产者-消费者模式实现的，任务相当于生产者，线程相当于消费者
当任务提交时会判断当前线程数是否大于核心线程数，如果没有就创建新的线程去执行任务
如果超过了线程数并且此时任务队列没有满，就把任务添加到队列中
如果队列也满了会判断当前线程数是否大于最大线程数，如果没有，则继续创建线程执行任务，否则就执行拒绝策略

实际应用
Executors 工具类
这个工具类提供工厂方法来创建 4 种不同的线程池，可缓存的线程池、固定大小的线程池、支持定时任务和周期任务的线程池、还有单线程化的线程池
像之前工作维护过的一些老项目就有使用这种方式的，但现在基本都会用 ThreadPoolExecutor，同时这也是阿里开发手册中的强制规范
因为 Executors 可能会出现问题，有的允许队列长度为 2 ^ 31 - 1 有的允许线程数量为 2 ^ 31 - 1 导致 OOM

ThreadPoolExecutor 
有一个重要参数：核心线程数、最大线程数、空闲时间、任务队列、拒绝策略
任务提交后会先交给核心线程处理，知道核心线程没有空闲的为止，此时会把任务添加到任务队列，阻塞队列可选择不同的类型，比如先来后到，ArrayBlockingQueue LinkedBlockingQueue 或者优先级队列 PriorityBlockingQueue
当任务队列也满了的时候，会创建额外的线程来处理任务，但是额外创建的线程数+核心线程数不能大于最大线程数，这个地方有个坑，就是不要创建太大的任务队列，不然可能一直满足不了创建额外线程的条件
当最大线程数也满足不了的时候就会执行拒绝策略了，一共四种
1 不再接受新任务，直接抛出异常
2 让提交任务的线程自己处理
3 丢弃以前的任务，处理当前任务
4 不处理，直接丢弃
在工作中其实大多数都是使用默认的拒绝策略，让问题及早的暴露出来，通过异常及时发现
核心线程数通常会配置成机器的CPU核数，最大线程数配置成2倍的核数

线程协作
synchronized
是JVM实现的，可以锁代码块、普通方法、静态方法、类，同步代码块和同步方法作用范围是同一个对象，而同步静态方法和同步类作用范围是当前类
底层是两个字节码实现的，因为是 JVM 实现的，所以看不了源码，但是可以用 javac 编译一个类，然后用 javap 查看类的字节码，会发现两个指令，monitorenter 和 monitorexit
具体思想是，每个类都有一个monitor 监视器，加锁会调用 monitorenter 尝试获取这个对象监视器，获取到就 +1，释放锁的话就 -1 重入会再 +1
但是用在方法上的话字节码中没有那两个指令，会有一个叫做 ACC_SYNCHRONIZED 的标记，这个标记会放在常量池中，原理是一样的
synchronized 获取不到锁会一直阻塞，不可以被中断，但是会自动释放锁

ReentrantLock 是 JUC 包提供的，只能对代码块加锁
底层是基于抽象式队列同步器实现的，通常在方法开始加锁，业务逻辑用try finally 包一下，在 finally 里面释放锁


Synchronized 锁优化
