# Java 虚拟机
## 1、运行时数据区
<!-- tabs:start -->

#### **参考回答**
?> **面试题：** 谈谈你对 JVM 内存模型的了解，以及每个区域的用途是什么？

- java虚拟机运行时数据区主要分线程隔离的和线程共享的；
-  <mark>&nbsp;线程隔离&nbsp;</mark>的有：<mark>&nbsp;程序计数器&nbsp;</mark> 、<mark>&nbsp;Java 虚拟机栈&nbsp;</mark> 、<mark>&nbsp;本地方法栈&nbsp;</mark> ；
    - 程序计数器主要同来记录正在执行的虚拟机字节码指令的地址，如果是正在执行的是本地方法则为空；
    - 然后每个方法执行的时候都要先创建一个`栈帧`，它里面主要保存着`局部变量表`、`操作数栈`、`常量池引用`等信息，方法从开始调用到执行结束对应着栈帧在 Java 虚拟机中`入栈`和`出栈`的过程；
    - 本地方法栈与虚拟机栈类似，只不过本地方法栈是为本地方法服务的，本地方法一般是 C、C++、汇编实现的，而且虚拟机没有对本地方法的语言、使用方式、数据结构做强制规定，可以由虚拟机自由实现，HotSpot 虚拟机就把二者合二为一了。
-  <mark>&nbsp;线程共享&nbsp;</mark>的有：<mark>&nbsp;堆&nbsp;</mark>和<mark>&nbsp;方法区&nbsp;</mark>，方法区中又包含<mark>&nbsp;运行时常量池&nbsp;</mark>；
    - `Java 堆`被所有`线程共享`，`几乎`所有的`对象实例`都在`堆分配内存`，之所以说几乎，是因为随着 JIT 编译器的发展，在编译时期经过`逃逸分析`，如果发现有些对象没有逃逸出方法，那么就有可能被`优化`成在虚拟机`栈上分配内存`，但这个不是绝对的；
    - Java 堆是`垃圾收集器`管理的主要区域，也被称为 `GC 堆`，现代的垃圾收集器基本都是采用`分代收集算法`，所有堆被分为`新生代 Young Generation`和`老年代 Old Generation`；
    - 堆不需要连续内存，可以动态增加内存，增加失败抛出 OutOfMemoryError 错误；

#### **源码详解**



<!-- tabs:end -->

## 2、垃圾回收
?> **面试题：** JVM 是怎么进行对象回收判断的，具体的垃圾回收算法是什么？

<!-- tabs:start -->

#### **参考回答**

### 1）对象回收判断
- 有<mark>&nbsp;引用计数器算法&nbsp;</mark>，原理主要是给对象添加一个引用计数器，每当对象增加一个引用计数器就加 1，引用失效计数器就减 1，引用计数器为 0 的对象可以被回收，但是，当两个对象出现循环引用的时候，计数器永远不为 0，导致对象无法被回收，所以虚拟机现在都不采用这种算法；
- 还有一种是<mark>&nbsp;可达性分析算法&nbsp;</mark>，原理是以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的就是能被回收的，现在的虚拟机大多采用的是这种算法。

### 2）垃圾回收算法
- <mark>&nbsp;标记-清除&nbsp;</mark>算法：标记阶段会根据对象的存活状态在对象头部打上标记，清除阶段回收对象取消标志位，另外，还会将当前回收的区块和前一个连续的空闲区块合并，但是在分配的时候会将大区块分隔成多个小区块，这样就会产生不连续的内存碎片，导致无法给大对象分配内存；
- <mark>&nbsp;标记-整理&nbsp;</mark>算法：让所有存活的对象都往一端移动，然后直接清理边界意外的内存，虽然这样不会产生内存碎片，但是需要移动大量对象，处理效率比较低；
- <mark>&nbsp;复制&nbsp;</mark>算法：原理是将内存划分成大小相等的两块，每次只是用其中一块，当这一块内存用完就将还存活的对象复制到一个块上，然后清理之前那一块，但这种效率只有 50%；
- 现在的商业虚拟机都是采用这种算法回收新生代，但不是分成相等的两块，而是一块较大的 <mark>&nbsp;Eden&nbsp;</mark> 空间和两块较小的 <mark>&nbsp;Survivor&nbsp;</mark> 空间，每次使用一块 Eden 和一块 Survivor ，回收的时候，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor；
- HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 <mark>&nbsp;8:1&nbsp;</mark>，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。
- <mark>&nbsp;分代收集&nbsp;</mark>：现在的商业虚拟机基本都采用分代收集，一般将堆划分成<mark>&nbsp;新生代&nbsp;</mark>和<mark>&nbsp;老年代&nbsp;</mark>，新生代通常使用`复制算法`，老年代使用`标记 - 清除`或者`标记 - 整理`算法；

#### **源码详解**



<!-- tabs:end -->

## 3、垃圾收集器

## 4、内存分配和回收策略

## 5、类加载机制


JVM毫无意外，大厂必须问，
垃圾回收算法，
垃圾收集器，
jvm内存模型，每个区域用途，

各种oom的种类，
jvm调优经验，没有你也要做过，自己去设置启动参数，知道常见参数的含义，

类加载过程，
双亲委派，
什么时候young gc，full gc，各种情况进入老年代的方式，你知道的越多越好，因为吹起来就越自信，举个例子，逃逸分析是什么？markword里面有什么？