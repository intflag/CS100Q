# Java 虚拟机
## 1、运行时数据区
<!-- tabs:start -->

#### **参考回答**
?> **面试题：** 谈谈你对 JVM 内存模型的了解，以及每个区域的用途是什么？

- java虚拟机运行时数据区主要分线程隔离的和线程共享的；
-  <mark>&nbsp;线程隔离&nbsp;</mark>的有：<mark>&nbsp;程序计数器&nbsp;</mark> 、<mark>&nbsp;Java 虚拟机栈&nbsp;</mark> 、<mark>&nbsp;本地方法栈&nbsp;</mark> ；
    - 程序计数器，也叫 PC 寄存器，每个线程都有自己的程序计数器，如果当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址，如果执行的是 native 方法，则 PC 寄存器中为空；
    - 然后每个方法执行的时候都要先创建一个`栈帧`，它里面主要保存着`局部变量表`、`操作数栈`、`常量池引用`等信息，方法从开始调用到执行结束对应着栈帧在 Java 虚拟机中`入栈`和`出栈`的过程；
    - 本地方法栈与虚拟机栈类似，只不过本地方法栈是为本地方法服务的，本地方法一般是 C、C++、汇编实现的，而且虚拟机没有对本地方法的语言、使用方式、数据结构做强制规定，可以由虚拟机自由实现，HotSpot 虚拟机就把二者合二为一了。
-  <mark>&nbsp;线程共享&nbsp;</mark>的有：<mark>&nbsp;堆&nbsp;</mark>和<mark>&nbsp;方法区&nbsp;</mark>，方法区中又包含<mark>&nbsp;运行时常量池&nbsp;</mark>；
    - `Java 堆`被所有`线程共享`，`几乎`所有的`对象实例`都在`堆分配内存`，之所以说几乎，是因为随着 JIT 编译器的发展，在编译时期经过`逃逸分析`，如果发现有些对象没有逃逸出方法，那么就有可能被`优化`成在虚拟机`栈上分配内存`，但这个不是绝对的；
    - Java 堆是`垃圾收集器`管理的主要区域，也被称为 `GC 堆`，现代的垃圾收集器基本都是采用`分代收集算法`，所有堆被分为`新生代 Young Generation`和`老年代 Old Generation`；
    - 堆不需要连续内存，可以动态增加内存，增加失败抛出 OutOfMemoryError 错误；
    - 在 JDK 7 中，方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中；
    - 方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式，在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中，元空间存储类的元信息，静态变量和常量池等放入堆中。

#### **源码详解**

### 参考资料
- [Metaspace 之一：Metaspace整体介绍（永久代被替换原因、元空间特点、元空间内存查看分析方法）](https://www.cnblogs.com/duanxz/p/3520829.html)

<!-- tabs:end -->

## 2、垃圾回收
?> **面试题：** JVM 是怎么进行对象回收判断的，具体的垃圾回收算法是什么？

<!-- tabs:start -->

#### **参考回答**

### 1）对象回收判断
- 有<mark>&nbsp;引用计数器算法&nbsp;</mark>，原理主要是给对象添加一个引用计数器，每当对象增加一个引用计数器就加 1，引用失效计数器就减 1，引用计数器为 0 的对象可以被回收，但是，当两个对象出现循环引用的时候，计数器永远不为 0，导致对象无法被回收，所以虚拟机现在都不采用这种算法；
- 还有一种是<mark>&nbsp;可达性分析算法&nbsp;</mark>，原理是以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的就是能被回收的，现在的虚拟机大多采用的是这种算法。

### 2）垃圾回收算法
- <mark>&nbsp;标记-清除&nbsp;</mark>算法：标记阶段会根据对象的存活状态在对象头部打上标记，清除阶段回收对象取消标志位，另外，还会将当前回收的区块和前一个连续的空闲区块合并，但是在分配的时候会将大区块分隔成多个小区块，这样就会产生不连续的内存碎片，导致无法给大对象分配内存；
- <mark>&nbsp;标记-整理&nbsp;</mark>算法：让所有存活的对象都往一端移动，然后直接清理边界以外的内存，虽然这样不会产生内存碎片，但是需要移动大量对象，处理效率比较低；
- <mark>&nbsp;复制&nbsp;</mark>算法：原理是将内存划分成大小相等的两块，每次只是用其中一块，当这一块内存用完就将还存活的对象复制到另一块上，然后清理之前那一块，但这种效率只有 50%；
- 现在的商业虚拟机都是采用这种算法回收新生代，但不是分成相等的两块，而是一块较大的 <mark>&nbsp;Eden&nbsp;</mark> 空间和两块较小的 <mark>&nbsp;Survivor&nbsp;</mark> 空间，每次使用一块 Eden 和一块 Survivor ，回收的时候，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor；
- HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 <mark>&nbsp;8:1&nbsp;</mark>，保证了内存的利用率达到 90%。如果每次回收时有超过 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。
- <mark>&nbsp;分代收集&nbsp;</mark>：现在的商业虚拟机基本都采用分代收集，一般将堆划分成<mark>&nbsp;新生代&nbsp;</mark>和<mark>&nbsp;老年代&nbsp;</mark>，新生代通常使用`复制算法`，老年代使用`标记-清除`或者`标记-整理`算法；

#### **源码详解**



<!-- tabs:end -->

## 3、垃圾收集器
?> **面试题：** JVM 有哪些垃圾收集器，各自的优缺点及使用场景是什么？

<!-- tabs:start -->

#### **参考回答**
常见的垃圾收集器有 7 种，新生代收集器有：Serial、ParNew、Parallel Scavenge，老年代收集器有：Serial Old、Parallel Old、CMS，堆内存垃圾收集器有：G1；

### 1）新生代收集器
- <mark>&nbsp;Serial&nbsp;</mark> 回收的范围是新生代，采用单线程和复制算法进行垃圾收集，它在收集时所有的用户线程都要等待，适合在 Client 场景下使用，能与其搭配的老年代收集器是 CMS 与 Serial Old；
- <mark>&nbsp;ParNew&nbsp;</mark> 收集的范围也是新生代，但它使用多线程和复制算法进行垃圾收集，相当于 Serial 收集器的多线程版本，适合在 Server 场景下使用，能与其搭配的老年代收集器是 CMS 与 Serial Old；
- <mark>&nbsp;Parallel Scavenge&nbsp;</mark> 同样用来回收新生代，采用多线程和复制算法进行垃圾收集，但是它和 ParNew 不同的是，它会尽可能的缩短垃圾收集时用户线程的停顿时间，来达到一个可控制的吞吐量，比如程序一共运行了 100 分钟，垃圾回收占用 1 分钟，那吞吐量就等于 99%；
- 它还可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），默认是开启的，这样就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量；
- 适合比较注重吞吐量，能高效利用 CPU 进行计算，且不需要太多交互场景，因为如果频繁交互，就需要缩短停顿时间，垃圾回收更频繁，吞吐量降低；

### 2）老年代收集器
- <mark>&nbsp;Serial Old &nbsp;</mark> 收集器是 Serial 的老年代版本，采用单线程和标记-整理算法进行垃圾收集，适合在 Client 场景下使用，与 Parallel Scavenge 收集器搭配，作为 CMS 收集器的后备预案；
- <mark>&nbsp;Paraller Old&nbsp;</mark> 是 Parallel Scavenge 的老年代版本，采用多线程和标记-整理算法进行垃圾收集；
- <mark>&nbsp;CMS (Concurrent Mark Sweep)&nbsp;</mark> 从名字上就可以知道它采用的是标记-清除算法，垃圾回收主要包含 4 个步骤：
    - 初始标记：标记一下 GC Roots 能直接关联到的对象，速度较快，需要停顿；
    - 并发标记：进行 GC Roots Tracing，标记出全部的垃圾对象，耗时较长，不需要停顿；
    - 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
    - 并发清除：用标记-清除算法清除垃圾对象，耗时较长，不需要停顿。
- CMS 收集器也有一些缺点：
    - 并发阶段会和工作现场争抢 CPU 资源；
    - 采用标记-清除算法会产生空间碎片，虚拟机提供一个参数，用于当 CMS 顶不住需要进行 FullGC 时整理空间碎片，但是整理的过程是用户线程是得停止工作的，所以停顿的时间会变长；
    - 浮动垃圾问题，因为在并发清理的时候允许用户线程继续执行，而执行就可能产生新的垃圾进入老年代，所以需要预留一部分空间给这些浮动垃圾，而当这些浮动垃圾过多在 CMS 运行期间爆了，那 CMS 就会出现 Concurrent Mode Failure ，这是时候就得后备的 Serial Old 上来重新进行老年代的垃圾收集，所以停顿的时间就更长了。
    
### 3）G1 收集器
- <mark>&nbsp;G1 (Garbage-First)&nbsp;</mark> 是 HotSpot JDK1.7 时出现的可商用垃圾收集器，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能，HotSpot 团队研发它的目的是为了在以后能替换掉 JDK 1.5 中发布的 CMS 收集器；
- 堆被分为新生代和老年代，其它收集器进行收集的范围要么是新生代，要么是老年代，而 G1 可以直接对新生代和老年代一起回收，能这样做的原因是 G1 把堆划分成多个大小相等的独立区域 Region ，新生代和老年代不再物理隔离，每个 Region 可以单独进行垃圾回收；
- 这种方式带来的好处是可以预测停顿时间，就是把每个 Region 每次垃圾回收的时间和获得的空间记录下来，当做下一次的参考，并维护了一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region；
- 但也有一个问题，就是如果一个 Region 中的对象引用了另外一个 Region 中的对象，在做可达性分析的时候就需要全堆扫描，效率太低，为了解决这个问题，给每个 Region 加了一个 Remembered Set，用来记录该 Region 对象引用的其他对象所在的 Region，这样就避免了全堆扫描；
- 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：
    - 初始标记（Initial Marking）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的 Region 中创建对象，此阶段需要停顿线程，但耗时很短；
    - 并发标记（Concurrent Marking）：从 GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行；
    - 最终标记（Final Marking）：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可多线程执行。
    - 筛选回收（Live Data Counting and Evacuation）：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

#### **源码详解**

![](http://images.intflag.com/jvm08.png)

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行与并发：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并发指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

|收集器|范围|运行模式|算法|目标|适用场景|
|:----:|:----:|:----:|:----:|:----:|:----:|
|Serial|新生代|单线程串行|复制算法|响应速度优先|单CPU环境下的Client模式|
|ParNew|新生代|多线程串行|复制算法|响应速度优先|多CPU环境时在Server模式下与CMS配合|
|Parallel Scavenge|新生代|多线程串行|复制算法|吞吐量优先|在后台运算而不需要太多交互的任务|
|Serial Old|老年代|多线程串行|标记-整理|响应速度优先|单CPU环境下的Client模式、CMS的后备预案|
|Parallel Old|老年代|多线程串行|标记-整理|吞吐量优先|在后台运算而不需要太多交互的任务|
|CMS|老年代|并发|标记-清除|响应速度优先|集中在互联网站或B/S系统服务端上的Java应用|
|G1|both|并发|标记-整理+复制算法|响应速度优先|面向服务端应用，将来替换CMS|

### 1）Serial 收集器

![](http://images.intflag.com/jvm09.png)

Serial 翻译为串行，也就是说它以串行的方式执行。

它是单线程的收集器，只会使用一个线程进行垃圾收集工作。

它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。

### 2）PerNew 收集器

![](http://images.intflag.com/jvm10.png)

它是 Serial 收集器的多线程版本。

它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

### 3）Parallel Scavenge 收集器

与 ParNew 一样是多线程收集器。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

### 4）Serial Old 收集器

![](http://images.intflag.com/jvm11.png)

是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

### 5）Parallel Old 收集器

![](http://images.intflag.com/jvm12.png)

是 Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### 6）CMS 收集器

![](http://images.intflag.com/jvm13.png)

CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。

分为以下四个流程：

- 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
- 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- 并发清除：不需要停顿。
在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

具有以下缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

### 7）G1 收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。

![](http://images.intflag.com/jvm14.png)

G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。

![](http://images.intflag.com/jvm15.png)

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![](http://images.intflag.com/jvm16.png)

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

具备如下特点：

- 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

### 参考资料
- [cyc2018 垃圾收集器](https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA?id=%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8)

<!-- tabs:end -->


## 4、内存分配和回收策略
?> **面试题：** 对象在内存上的分配策略具体有哪些？
- <mark>&nbsp;对象优先在 Eden 分配&nbsp;</mark>：大多数情况下，对象在新生代 Eden 区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC；
- <mark>&nbsp;大对象直接进入老年代&nbsp;</mark>：因为对象优先在新生代 Eden 区分配的原则，大对象在分配时很可能出现空间不足，这时候需要移动大量小的年轻对象进入年老代，这对 GC 代价很高，所以 JVM 中有一个阈值，如果发现对象大小超过了这个值会直接将对象分配到老年代，当然这个值可以手动修改；
- <mark>&nbsp;长期存活的对象进入老年代&nbsp;</mark>：虚拟机为每个对象都维护一个年龄。如果对象在 Eden 区，经过一次 GC 后依然存活，则被移动到 Survivor 区中，对象年龄加 1，以后，如果对象每经过一次 GC 依然存活，则年龄再加 1，当对象年龄达到阈值时，就移入年老代，默认阈值是15；
- <mark>&nbsp;动态年龄判定&nbsp;</mark>：如果在 Survivor 空间中相同年龄所有对象大小的总和大于Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，不需要等到15岁。
- <mark>&nbsp;空间分配担保&nbsp;</mark>：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果大于的话，就认为 Minor GC 是安全的，如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC，如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

?> **面试题：** 什么时候进行 Minor GC，什么时候 Full GC？

- 对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC；
- 而 Full GC 比较复杂，有以下条件：
    - <mark>&nbsp;调用 System.gc()&nbsp;</mark>：只是建议虚拟机执行 Full GC，调用了以后不一定真正执行；
    - <mark>&nbsp;老年代空间不足&nbsp;</mark>：因为超过阈值的大对象会直接在老年代分配，所以当老年代空间不足就会引发 Full GC，所以尽量不要创建太大的对象和数组，除此之外，可以通过一个虚拟机参数调大新生代的大小，让对象尽量在新生代就被回收掉，还可以调大对象进入老年代的年龄，让对象在新生代多活一段时间；
    - <mark>&nbsp;空间分配担保失败&nbsp;</mark>：因为使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC；
    - <mark>&nbsp;JDK 1.7 及以前的永久代空间不足&nbsp;</mark>：在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC，如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError，为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC；
    - <mark>&nbsp;Concurrent Mode Failure&nbsp;</mark>：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。


## 5、类加载机制
?> **面试题：** 一个 Java 类是经过那几个步骤加载到 JVM 中的？





各种oom的种类，
jvm调优经验，没有你也要做过，自己去设置启动参数，知道常见参数的含义，

类加载过程，
双亲委派，
什么时候young gc，full gc，各种情况进入老年代的方式，你知道的越多越好，因为吹起来就越自信，举个例子，逃逸分析是什么？markword里面有什么？